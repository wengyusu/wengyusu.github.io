<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP拥塞控制 | wind&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.799f9605.css" as="style"><link rel="preload" href="/assets/js/app.55e8c845.js" as="script"><link rel="preload" href="/assets/js/2.3188be17.js" as="script"><link rel="preload" href="/assets/js/5.5169be14.js" as="script"><link rel="prefetch" href="/assets/js/10.709fd580.js"><link rel="prefetch" href="/assets/js/11.b47eea71.js"><link rel="prefetch" href="/assets/js/12.cee93660.js"><link rel="prefetch" href="/assets/js/3.773a07e1.js"><link rel="prefetch" href="/assets/js/4.9dd11947.js"><link rel="prefetch" href="/assets/js/6.f8fc2551.js"><link rel="prefetch" href="/assets/js/7.284342ad.js"><link rel="prefetch" href="/assets/js/8.1c54fad9.js"><link rel="prefetch" href="/assets/js/9.54d08e9c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.799f9605.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open no-sidebar have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">wind's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <!---->  <!----> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><!----> <div class="info" data-v-0c557b5e><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2022-03-17</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">TCP拥塞控制<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="tcp拥塞控制"><a href="#tcp拥塞控制" class="header-anchor">#</a> TCP拥塞控制</h1> <h2 id="序言"><a href="#序言" class="header-anchor">#</a> 序言</h2> <p>时隔很多年又决定把博客重新更一下，虽然我的个性是不喜欢记录过去的事，但是事实证明不记录过去的经验最终还是会导致未来走很多弯路。</p> <p>作为新博客第一篇决定把以前review的论文重新发一下，第一篇就从Van Jacobson的<code>Congestion Avoidance and Control</code><a href="#refer-anchor-1"><sup>1</sup></a> 开始吧。在这篇论文中Jacobson为TCP协议提出了新的拥塞控制算法(也就是TCP Tahoe)，这个算法据说拯救了当时因特网网络拥塞的状况。</p> <h2 id="包守恒理论和慢启动"><a href="#包守恒理论和慢启动" class="header-anchor">#</a> 包守恒理论和慢启动</h2> <p>拥塞控制算法的目的是为了使链路中的流量达到一个稳定，饱和，平衡的状态(equilibrium), Jacobson称之为“数据包守衡”(Conservation of packets): <strong> 链路上的数据包达到饱和，并且只有当一个老的数据包达到目的地时，另一个新的数据包才会进入网络中。</strong></p> <p>对于TCP协议而言，利用发送确认机制可以很容易地实现“数据包守衡”:只有当数据包到达接收方时，接收方才会发送ACK包进入网络；而只有发送方收到ACK包时，发送方才会发送新的数据包进入网络。</p> <p>然而在实际场景中，“数据包守衡”可能会被打破:</p> <ul><li><p>链路未达到饱和</p></li> <li><p>老数据包到达之前新数据包就已经被发送了</p></li> <li><p>由于链路资源限制导致平衡状态无法实现</p></li></ul> <p>第一个场景往往出现在新的连接刚刚建立或者重传刚开始的时候，发送确认机制只提供了维持平衡状态的能力，但并没有告诉发送方和接收方该怎样达到平衡状态。对于一条新的连接来说，TCP协议还需要考虑发送方一开始应该发送多少数据包，如何尽可能地利用链路上的带宽而又不至于超出带宽限制导致丢包或者重传，这就是慢启动算法的诞生原因。如果没有慢启动算法，那么或许我们可以想象一下下面的场景(:</p> <p>发送方：我需要收到更多ACK包才能发送更多的数据包！</p> <p>接收方：你需要首先发送更多数据包我才能给你回更多的ACK包！</p> <p>发送方：你不回更多ACK包我怎么发更多数据包啊！(摔椅子)</p> <p>慢启动算法将初始拥塞窗口(cwnd)设置为1，每收到一个ACK包的时候，cwnd+1,所以每经过一个RTT，cwnd会变为原来的两倍。</p> <p><img src="/assets/img/1.2cbe1e5e.png" alt="慢启动"></p> <h2 id="rtt估算"><a href="#rtt估算" class="header-anchor">#</a> RTT估算</h2> <p>有了慢启动算法后，现在我们的流量可以维持在一个稳定饱和的状态，接下来我们来考虑一下场景二:</p> <ul><li>老数据包到达之前新数据包就已经被发送了。</li></ul> <p>出现这种情况，意味着发送方的超时重传计时器出现了问题，把一个还未到达的包认为是丢失了，导致发送方在前一个包到达之前又发送了一个新的数据包。因此，为了避免场景二的出现，我们需要一个可靠的RTT(往返延时)估算方法。</p> <p>最早版本的TCP协议采用了一种名为低通滤波器的算法(我也不知道为啥叫这个名字)用来估算RTT，它还有另一个名字叫指数加权移动平均，该算法特点是假设RTT波动比较小</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>α</mi><mi>R</mi><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo>)</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R=\alpha R+(1-\alpha)M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span></p> <p>其中R是原RTT，M是根据最新到达的ACK包计算出的实时RTT, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.0037em;">α</span></span></span></span>是人为指定的系数，论文中的建议值为0.9</p> <p>有了新的RTT之后，就可以更新超时重传计时器RTO了，这里并没有直接将RTO=RTT,而是又乘了一个系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>:</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>β</mi><mo>∗</mo><mi>R</mi><mi>T</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">RTO=\beta *RTO</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05278em;">β</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>必须是一个大于1的值，论文给的建议值为2.</p> <p>之所以要有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>的原因是因为RTT估算还要考虑到RTT波动。量化一下就是RTT的标准差和链路负荷大致呈现一个反比关系，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\beta=2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span><span class="mrel">=</span><span class="mord mathrm">2</span></span></span></span>时大约能适应30%负荷的链路。</p> <p>当然30%这个值肯定是远远不够的，实际场景中采用固定的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05278em;">β</span></span></span></span>值来适应RTT波动状况显然是非常具有局限性的，因此Jacobson对RTT估算方法进行了改进:</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>R</mi><mi>R</mi><mo>=</mo><mi>M</mi><mo>−</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">ERR=M-R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>g</mi><mo>)</mo><mi>R</mi><mo>+</mo><mi>g</mi><mi>M</mi><mo>=</mo><mi>R</mi><mo>+</mo><mi>g</mi><mi>E</mi><mi>R</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">R=(1-g)R+gM=R+gERR</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mi>V</mi><mi>A</mi><mi>R</mi><mo>=</mo><mi>R</mi><mi>T</mi><mi>T</mi><mi>V</mi><mi>A</mi><mi>R</mi><mo>+</mo><mi>h</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi>R</mi><mi>R</mi><mo>−</mo><mi>R</mi><mi>T</mi><mi>T</mi><mi>V</mi><mi>A</mi><mi>R</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">RTTVAR=RTTVAR+h(|ERR-RTTVAR|)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathit">h</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>R</mi><mo>+</mo><mn>2</mn><mi>R</mi><mi>T</mi><mi>T</mi><mi>V</mi><mi>A</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">RTO=R+2RTTVAR</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span></p> <p>R的计算方法和原本一样，但是增加了一个新的参数RTTVAR，代表RTT的平均偏差值，同样采用指数加权移动平均来对RTTVAR进行估算，得到的结果近似于R的标准差，最后的RTO等于RTT加上2RTTVAR的偏差值。（现在的TCP实践似乎采用了4RTTVAR）</p> <h2 id="拥塞避免"><a href="#拥塞避免" class="header-anchor">#</a> 拥塞避免</h2> <p>当前面两个问题解决之后，第三个问题就变得很轻松了。在RTT估算比较精确的情况下，我们可以认为丢包=网络堵塞，接下来我们可以对网络的拥塞情况进行建模分析。</p> <p>假设网络没有堵塞时，对于任一时刻i,链路某一点的负载L恒等于一个常数N，N代表该时刻新到达的数据包:</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>i</mi></mrow></msub><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">L_{i}=N</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span></p> <p>但当拥塞发生时，数据包会在中间节点堆积，前一时刻的流量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">L_{i-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>会有一定比例残留在当前时刻<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>:</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>i</mi></mrow></msub><mo>=</mo><mi>N</mi><mo>+</mo><mi>γ</mi><msub><mi>L</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">L_{i}=N+\gamma L_{i-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p> <p>可以看出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{i}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>近似构成一个等比数列，说明拥塞流量会以指数级堆积，因此如果要避免拥塞，发送窗口也必须以同等速率缩小:</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><mi>d</mi><msub><mi>W</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>(</mo><mi>d</mi><mo>&lt;</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">W_i=dW_{i-1} (d&lt;1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit">d</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mrel">&lt;</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p> <p>除此之外，在拥塞控制阶段，仍然需要主动增加窗口来试探当前链路是否饱和，因为判断网络是否闲置比判断网络是否堵塞要困难很多。比如假设你的室友本来在和你共用一个网络，然后他关机了。但你的电脑并无法感知到这一情况，并且继续保持原有的拥塞窗口，那么多出来的带宽就会被白白浪费了。</p> <p>比较朴素的想法是把减小窗口的算法反过来当做增加窗口的算法，也就是所谓的multiplicative increase&amp;multiplicative decrease,但显然这一想法是非常天真的，因为网络拥塞的惩罚是非常严重的，将一个堵塞的网络重新恢复成平衡状态需要花费极高的代价，因此增加窗口的算法必须非常保守,增加速率必须控制在常数级:</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><msub><mi>W</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">W_i=W_{i-1}+u</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit">u</span></span></span></span></p> <p>综上，拥塞控制算法如下:</p> <ul><li><p>如果出现超时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">cwnd=cwnd/2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span></p></li> <li><p>如果收到一个新的ACK，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>+</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">cwnd=cwnd+1/cwnd</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mrel">=</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span></p></li> <li><p>发送窗口大小为接收方窗口大小和cwnd之间的最小值</p></li></ul> <h2 id="慢启动与拥塞控制的结合"><a href="#慢启动与拥塞控制的结合" class="header-anchor">#</a> 慢启动与拥塞控制的结合</h2> <p>到这里我们基本上已经把TCP拥塞控制的各个环节讲解了一遍(除了快速重传)，但仍然还有一个问题需要解决:如何将慢启动和拥塞避免结合在一起？答案是通过拥塞窗口cwnd和门限阈值ssthresh两个变量来控制两种算法的切换。当<code>cwnd&lt;ssthresh</code>时，进入慢启动阶段；当cwnd达到ssthresh时，进入拥塞控制阶段；出现超时时，将ssthresh设为cwnd/2,cwnd设为1。</p> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <div id="refer-anchor-1"></div> <ul><li>[1] <a href="http://www.cs.binghamton.edu/~nael/cs428-528/deeper/jacobson-congestion.pdf" target="_blank" rel="noopener noreferrer">Congestion Avoidance and Control<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" title="标签">#计算机网络</a></div> <!----></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/" class="router-link-active"><div>
            
            <!----></div></a> <span class="date"></span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.55e8c845.js" defer></script><script src="/assets/js/2.3188be17.js" defer></script><script src="/assets/js/5.5169be14.js" defer></script>
  </body>
</html>
